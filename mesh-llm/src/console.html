<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>mesh-llm</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      min-height: 100vh;
    }

    a {
      color: #6cf;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    .top-bar {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      padding: 0.6rem 1.25rem;
      border-bottom: 1px solid #1a1a1a;
    }

    .top-bar h1 {
      font-size: 1rem;
      font-weight: 600;
      color: #555;
      letter-spacing: 0.5px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.65rem;
      padding: 0.12rem 0.45rem;
      border-radius: 10px;
    }

    .badge .dot {
      width: 5px;
      height: 5px;
      border-radius: 50%;
    }

    .b-green {
      background: #0a1a0a;
      color: #4c4;
    }

    .b-green .dot {
      background: #4c4;
    }

    .b-yellow {
      background: #1a1a0a;
      color: #cc4;
    }

    .b-yellow .dot {
      background: #cc4;
    }

    .b-gray {
      background: #151515;
      color: #666;
    }

    .b-gray .dot {
      background: #555;
    }

    .top-right {
      margin-left: auto;
      font-size: 0.65rem;
      color: #555;
      display: flex;
      gap: 0.8rem;
      align-items: center;
    }

    .top-right span {
      color: #888;
    }

    /* Layout */
    .main {
      display: flex;
      height: calc(100vh - 38px);
    }

    /* Left panel â€” collapsible */
    .left {
      width: 30%;
      flex-shrink: 0;
      padding: 1rem 1.25rem;
      overflow-y: auto;
      border-right: 1px solid #1a1a1a;
      display: flex;
      flex-direction: column;
      transition: width 0.25s ease, padding 0.25s ease, opacity 0.2s ease;
    }

    .left.collapsed {
      width: 0;
      padding: 0;
      overflow: hidden;
      opacity: 0;
      border-right: none;
    }

    /* Toggle button */
    .toggle-btn {
      background: none;
      border: 1px solid #333;
      border-radius: 4px;
      color: #666;
      cursor: pointer;
      font-size: 0.65rem;
      padding: 0.15rem 0.4rem;
    }

    .toggle-btn:hover {
      color: #ccc;
      border-color: #666;
    }

    /* Chat â€” takes remaining space */
    .right {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      background: #060606;
    }

    /* Diagram */
    .diagram {
      flex-shrink: 0;
      margin-bottom: 0.75rem;
    }

    .diagram svg {
      width: 100%;
      display: block;
    }

    /* Status line */
    .status-line {
      font-size: 0.78rem;
      color: #666;
      margin-bottom: 0.6rem;
    }

    .status-line.ok {
      color: #4c4;
    }

    /* Section labels */
    .section-label {
      font-size: 0.68rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #444;
      margin: 0.6rem 0 0.25rem;
    }

    /* Agent rows */
    /* Models list */
    .models-list {
      margin-bottom: 0.5rem;
    }

    .model-item {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.72rem;
      padding: 0.15rem 0;
    }

    .model-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .model-dot.warm {
      background: #4c4;
    }

    .model-dot.cold {
      background: #444;
    }

    .model-name {
      color: #aaa;
      font-family: monospace;
    }

    .model-name.warm {
      color: #ccc;
    }

    .model-info {
      color: #444;
      font-size: 0.62rem;
      margin-left: auto;
    }

    .agent-row {
      display: flex;
      gap: 0.4rem;
      align-items: baseline;
      margin-bottom: 0.2rem;
    }

    .agent-name {
      font-size: 0.68rem;
      font-weight: 600;
      color: #555;
      min-width: 36px;
      flex-shrink: 0;
    }

    .cmd-sm {
      font-family: monospace;
      font-size: 0.62rem;
      color: #aaa;
      background: #080808;
      border: 1px solid #1a1a1a;
      border-radius: 3px;
      padding: 0.2rem 0.35rem;
      cursor: text;
      word-break: break-all;
      line-height: 1.4;
    }

    /* Join expand */
    .join-details {
      margin-top: 0.4rem;
    }

    .join-details>summary {
      font-size: 0.68rem;
      color: #444;
      cursor: pointer;
    }

    .join-details>summary:hover {
      color: #888;
    }

    .discover-item {
      background: #080808;
      border: 1px solid #1a1a1a;
      border-radius: 4px;
      padding: 0.4rem;
      margin-top: 0.3rem;
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .discover-item-hdr {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
    }

    .discover-name {
      font-size: 0.68rem;
      font-weight: 600;
      color: #6cf;
    }

    .discover-region {
      font-size: 0.58rem;
      color: #666;
      background: #111;
      padding: 0.1rem 0.25rem;
      border-radius: 2px;
    }

    .discover-stats {
      font-size: 0.62rem;
      color: #888;
    }

    .discover-models {
      font-size: 0.62rem;
      color: #aaa;
      font-family: monospace;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Collapsible sections */
    details.panel-section {
      border-top: 1px solid #1a1a1a;
      margin-top: 0.6rem;
      padding-top: 0.5rem;
      flex-shrink: 0;
    }

    details.panel-section > summary {
      font-size: 0.7rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      color: #888;
      cursor: pointer;
      list-style: none;
      display: flex;
      align-items: center;
      gap: 0.3rem;
    }
    details.panel-section > summary::-webkit-details-marker { display: none; }
    details.panel-section > summary::before {
      content: 'â–¸';
      font-size: 0.5rem;
      color: #555;
      transition: transform 0.15s;
    }
    details.panel-section[open] > summary::before {
      transform: rotate(90deg);
    }

    details.panel-section > summary:hover {
      color: #bbb;
    }

    details.panel-section[open] > summary {
      color: #aaa;
      margin-bottom: 0.4rem;
    }

    .panel-desc {
      font-size: 0.7rem;
      color: #777;
      line-height: 1.5;
      margin-bottom: 0.5rem;
    }

    .panel-row {
      margin-bottom: 0.4rem;
    }

    .panel-label {
      font-size: 0.62rem;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      margin-bottom: 0.15rem;
    }

    .panel-val {
      font-family: monospace;
      font-size: 0.68rem;
      color: #ccc;
      background: #0a0a0a;
      border: 1px solid #1a1a1a;
      border-radius: 4px;
      padding: 0.3rem 0.5rem;
      user-select: all;
      cursor: text;
      word-break: break-all;
    }

    .panel-tok {
      font-family: monospace;
      font-size: 0.6rem;
      color: #999;
      background: #0a0a0a;
      border: 1px solid #1a1a1a;
      border-radius: 4px;
      padding: 0.3rem 0.5rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .panel-btn {
      background: #1a3a5c;
      border: 1px solid #2a5a8c;
      border-radius: 4px;
      padding: 0.25rem 0.6rem;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 0.62rem;
      white-space: nowrap;
      flex-shrink: 0;
    }
    .panel-btn:hover { background: #2a4a6c; }
    .panel-btn:disabled { opacity: 0.3; cursor: default; }

    .copy-btn {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 4px;
      padding: 0.2rem 0.5rem;
      color: #aaa;
      cursor: pointer;
      font-size: 0.62rem;
      white-space: nowrap;
      flex-shrink: 0;
    }
    .copy-btn:hover { background: #252525; color: #ccc; }

    /* Chat */
    .chat-hdr {
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid #1a1a1a;
      font-size: 0.7rem;
      color: #555;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .chat-hdr-title {
      flex: 1;
    }

    .model-picker {
      background: #0a0a0a;
      border: 1px solid #222;
      border-radius: 4px;
      color: #aaa;
      font-size: 0.65rem;
      font-family: monospace;
      padding: 0.15rem 0.3rem;
      cursor: pointer;
      max-width: 180px;
    }

    .model-picker:focus {
      outline: none;
      border-color: #6cf;
    }

    .model-picker option {
      background: #0a0a0a;
      color: #ccc;
    }

    .chat-msgs {
      flex: 1;
      overflow-y: auto;
      padding: 0.75rem 1rem;
      font-size: 0.9rem;
      line-height: 1.6;
    }

    .chat-msgs:empty::before {
      content: "Send a message to test the modelâ€¦";
      color: #222;
      font-style: italic;
      font-size: 0.85rem;
    }

    .chat-msgs.off:empty::before {
      content: "Waiting for model to loadâ€¦";
    }

    .chat-in {
      display: flex;
      gap: 0.5rem;
      padding: 0.6rem 0.75rem;
      border-top: 1px solid #1a1a1a;
      flex-shrink: 0;
    }

    .chat-in input {
      flex: 1;
      background: #0a0a0a;
      border: 1px solid #222;
      border-radius: 6px;
      padding: 0.5rem 0.75rem;
      color: #e0e0e0;
      font-size: 0.9rem;
    }

    .chat-in input:focus {
      outline: none;
      border-color: #6cf;
    }

    .chat-in input:disabled {
      opacity: 0.3;
    }

    .chat-in button {
      background: #1a3a5c;
      border: 1px solid #2a5a8c;
      border-radius: 6px;
      padding: 0.5rem 0.9rem;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 0.85rem;
    }

    .chat-in button:hover {
      background: #2a4a6c;
    }

    .chat-in button:disabled {
      opacity: 0.3;
      cursor: default;
    }

    .mu {
      color: #6cf;
      margin-bottom: 0.15rem;
    }

    .mb {
      color: #ccc;
      margin-bottom: 0.6rem;
      white-space: pre-wrap;
    }

    .me {
      color: #c66;
      font-size: 0.75rem;
      margin-bottom: 0.6rem;
    }

    .mmeta {
      color: #666;
      font-size: 0.72rem;
      margin-top: -0.35rem;
      margin-bottom: 0.7rem;
      font-family: monospace;
    }

    .hidden {
      display: none !important;
    }

    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.35rem;
      margin: 0.35rem 0 0.55rem;
    }

    .metric-card {
      border: 1px solid #1a1a1a;
      border-radius: 4px;
      background: #090909;
      padding: 0.35rem 0.45rem;
    }

    .metric-k {
      color: #555;
      font-size: 0.58rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      margin-bottom: 0.1rem;
    }

    .metric-v {
      color: #ccc;
      font-family: monospace;
      font-size: 0.84rem;
    }

    .metric-sub {
      color: #666;
      font-size: 0.58rem;
      margin-top: 0.1rem;
    }

    .telemetry-chart {
      border: 1px solid #1a1a1a;
      border-radius: 4px;
      background: #090909;
      padding: 0.3rem 0.35rem;
      margin: 0.35rem 0;
    }

    .telemetry-chart .label {
      color: #666;
      font-size: 0.6rem;
      margin-bottom: 0.2rem;
      display: flex;
      justify-content: space-between;
    }

    .telemetry-chart svg {
      width: 100%;
      height: 36px;
      display: block;
    }

    .telemetry-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.64rem;
      margin-top: 0.3rem;
    }

    .telemetry-table th {
      color: #555;
      text-align: left;
      font-weight: 600;
      border-bottom: 1px solid #1a1a1a;
      padding: 0.2rem 0.18rem;
      font-size: 0.56rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .telemetry-table td {
      color: #aaa;
      border-bottom: 1px solid #111;
      padding: 0.22rem 0.18rem;
      font-family: monospace;
      vertical-align: middle;
    }

    .telemetry-row {
      cursor: pointer;
    }

    .telemetry-row:hover td {
      background: #0d0d0d;
    }

    .telemetry-row.sel td {
      background: #0d141a;
      color: #cce9ff;
    }

    .fresh-dot {
      display: inline-block;
      width: 5px;
      height: 5px;
      border-radius: 50%;
      margin-right: 0.28rem;
      background: #444;
    }
    .fresh-dot.ok { background: #4c4; }
    .fresh-dot.warn { background: #cc4; }
    .fresh-dot.stale { background: #c66; }

    @media (max-width: 720px) {
      .main {
        flex-direction: column;
        height: auto;
      }

      .left {
        width: 100% !important;
        border-right: none;
        border-bottom: 1px solid #1a1a1a;
        max-height: 50vh;
      }

      .left.collapsed {
        max-height: 0;
      }

      .right {
        width: 100%;
        min-height: 50vh;
      }

      .metrics-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>

  <div class="top-bar">
    <h1>meshÂ·llm</h1>
    <span id="badge"></span>
    <span id="meshName" style="font-size:0.7rem;color:#6cf;font-weight:600"></span>
    <div class="top-right" id="meta"></div>
  </div>

  <div class="main">
    <div class="left" id="leftPanel">
      <div class="diagram" id="diagram"></div>
      <div id="status"></div>
      <div id="models"></div>
      <div id="agents"></div>
      <div id="inviteSection"></div>
      <div id="discoverSection"></div>
      <div id="gettingStarted"></div>
      <div id="apiSection"></div>
      <div id="metricsSection"></div>
    </div>
    <div class="right">
      <div class="chat-hdr">
        <button class="toggle-btn" id="toggleBtn" onclick="togglePanel()" title="Toggle topology panel">â—€ Mesh</button>
        <span class="chat-hdr-title" id="chatHdr">Chat</span>
        <select id="modelPicker" class="model-picker" title="Select model" onchange="renderDiagram()"></select>
      </div>
      <div class="chat-msgs" id="msgs"></div>
      <div class="chat-in">
        <input type="text" id="inp" placeholder="Say somethingâ€¦" onkeydown="if(event.key==='Enter')send()" disabled>
        <button id="btn" onclick="send()" disabled>Send</button>
      </div>
    </div>
  </div>

  <script>
    const $ = id => document.getElementById(id);
    let S = {};
    let T = { live: null, nodes: [], rollup: [], nodeHistory: [], benchmarks: [], selectedNodeId: null, rangeMinutes: 180, loading: false, loadedOnce: false, err: null, lastLoadMs: 0 };
    let telemetrySse = null;
    let panelOpen = true;
    const sse = new EventSource('/api/events');
    sse.onmessage = e => { S = JSON.parse(e.data); render(); };

    function togglePanel() {
      panelOpen = !panelOpen;
      $('leftPanel').classList.toggle('collapsed', !panelOpen);
      $('toggleBtn').textContent = panelOpen ? 'â—€ Mesh' : 'â–¶ Mesh';
    }

    function render() {
      renderMeshName(); renderBadge(); renderMeta(); renderGettingStarted(); renderDiagram(); renderStatus(); renderModels(); renderAgents(); renderInvite(); renderDiscover(); renderApiSection(); renderTelemetry();
      const hasWarmModel = (S.mesh_models || []).some(m => m.status === 'warm');
      const ok = S.llama_ready || (S.is_client && hasWarmModel);
      $('inp').disabled = !ok; $('btn').disabled = !ok;
      $('msgs').classList.toggle('off', !ok);
      if (ok) $('msgs').classList.remove('off');
      updateModelPicker();
      $('chatHdr').textContent = ok ? 'Chat' : 'Chat';
    }

    async function loadTelemetry(force = false) {
      if (T.loading) return;
      const now = Date.now();
      if (!force && now - (T.lastLoadMs || 0) < 8000) return;
      T.loading = true;
      T.lastLoadMs = now;
      try {
        const selected = T.selectedNodeId || S.node_id || '';
        const m = T.rangeMinutes || 180;
        const [liveR, nodesR, rollupR, nodeR, benchR] = await Promise.all([
          fetch('/api/metrics/live'),
          fetch(`/api/metrics/nodes?minutes=${m}`),
          fetch(`/api/metrics/rollup?minutes=${m}`),
          fetch(`/api/metrics/node?minutes=${m}${selected ? `&id=${encodeURIComponent(selected)}` : ''}`),
          fetch(`/api/metrics/benchmarks?minutes=${m}&limit=300`),
        ]);
        if (!liveR.ok || !nodesR.ok || !rollupR.ok || !nodeR.ok || !benchR.ok) throw new Error('metrics fetch failed');
        T.live = await liveR.json();
        T.nodes = await nodesR.json();
        T.rollup = await rollupR.json();
        T.nodeHistory = await nodeR.json();
        T.benchmarks = await benchR.json();
        if (!T.selectedNodeId) {
          T.selectedNodeId = S.node_id || (T.nodes[0] && T.nodes[0].source_node_id) || null;
        }
        T.err = null;
        T.loadedOnce = true;
      } catch (e) {
        T.err = e.message || String(e);
      } finally {
        T.loading = false;
        renderTelemetry();
      }
    }

    function telemetryEventsUrl() {
      const m = T.rangeMinutes || 180;
      const sel = T.selectedNodeId || S.node_id || '';
      const q = new URLSearchParams();
      q.set('minutes', String(m));
      q.set('limit', '300');
      if (sel) q.set('id', sel);
      return `/api/metrics/events?${q.toString()}`;
    }

    function connectTelemetrySse() {
      const url = telemetryEventsUrl();
      if (telemetrySse && telemetrySse._url === url) return;
      if (telemetrySse) {
        telemetrySse.close();
        telemetrySse = null;
      }
      try {
        const es = new EventSource(url);
        es._url = url;
        es.onmessage = e => {
          try {
            const d = JSON.parse(e.data);
            T.live = d.live || null;
            T.nodes = d.nodes || [];
            T.rollup = d.rollup || [];
            T.nodeHistory = d.node_history || [];
            T.benchmarks = d.benchmarks || [];
            if (!T.selectedNodeId) T.selectedNodeId = S.node_id || (T.nodes[0] && T.nodes[0].source_node_id) || null;
            T.err = null;
            T.loadedOnce = true;
            renderTelemetry();
          } catch (err) {
            T.err = 'bad telemetry SSE payload';
            renderTelemetry();
          }
        };
        es.onerror = () => {
          T.err = 'telemetry stream disconnected';
          renderTelemetry();
          // Keep a fetch fallback so the panel still updates if SSE is flaky.
          loadTelemetry(true);
        };
        telemetrySse = es;
      } catch (e) {
        T.err = 'telemetry SSE unavailable';
        loadTelemetry(true);
      }
    }

    function renderTelemetry() {
      const el = $('metricsSection');
      if (!el) return;
      if (!T.loadedOnce && !T.loading) loadTelemetry();
      const roll = T.rollup || [];
      const rollLast = roll[roll.length - 1] || null;
      const p95Avg = rollLast ? latestDefined(roll.map(r => r.latency_p95_ms_avg_nodes || null)) : null;
      const p95Max = rollLast ? latestDefined(roll.map(r => r.latency_p95_ms_max_nodes || null)) : null;
      const reqLast = rollLast ? rollLast.requests : 0;
      const errRate = rollLast && rollLast.requests > 0 ? (rollLast.errors / rollLast.requests * 100) : 0;
      const util = rollLast ? rollLast.utilization_pct_avg_nodes : 0;
      const nodes = T.nodes || [];
      const freshCount = nodes.filter(n => freshnessClass(n.observed_at) === 'ok').length;
      const selectedId = T.selectedNodeId || (S.node_id || '');
      const selectedRow = nodes.find(n => n.source_node_id === selectedId) || null;
      const nodeHist = T.nodeHistory || [];
      const benches = T.benchmarks || [];
      const benchLatestByProbe = latestBy(benches, b => b.probe_name);

      el.innerHTML = `<details class="panel-section" open>
        <summary>Telemetry</summary>
        <div style="display:flex;align-items:center;gap:0.4rem;margin:0.25rem 0 0.45rem">
          <div style="font-size:0.55rem;color:#666;text-transform:uppercase;letter-spacing:0.04em">Range</div>
          <select class="model-picker" style="max-width:90px" onchange="setTelemetryRange(this.value)">
            ${[15,60,180,1440].map(v => `<option value="${v}" ${T.rangeMinutes===v?'selected':''}>${v >= 60 ? (v===1440?'24h':(v/60)+'h') : v+'m'}</option>`).join('')}
          </select>
          <button class="copy-btn" onclick="loadTelemetry(true)">Refresh</button>
        </div>
        ${T.err ? `<div style="color:#c66;font-size:0.58rem;margin-bottom:0.35rem">Metrics unavailable: ${esc(T.err)}</div>` : ''}
        <div class="metrics-grid">
          ${metricCard('Req/min', fmtInt(reqLast), `${rollLast ? rollLast.node_count : 0} nodes Â· ${freshCount} fresh`)}
          ${metricCard('Errors', rollLast ? `${fmtInt(rollLast.errors)} (${errRate.toFixed(1)}%)` : '0', '')}
          ${metricCard('Util Avg', `${(util || 0).toFixed(1)}%`, 'avg across reporting nodes')}
          ${metricCard('Latency p95', p95Avg != null ? `${fmtMaybeMs(p95Avg)} avg` : 'n/a', p95Max != null ? `max ${fmtMaybeMs(p95Max)}` : '')}
          ${metricCard('Tunnel Bytes', rollLast ? fmtBytes(rollLast.tunnel_bytes_total) : '0 B', 'sum / min')}
        </div>
        ${miniChart('Requests/min', roll.map(r => r.requests), '#6cf')}
        ${miniChart('Utilization avg %', roll.map(r => r.utilization_pct_avg_nodes), '#cc8')}
        ${miniChart('Latency p95 avg nodes (ms)', roll.map(r => r.latency_p95_ms_avg_nodes), '#8c8')}
        ${miniChart('Errors/min', roll.map(r => r.errors), '#c66')}
        <div class="section-label" style="margin-top:0.55rem">All Nodes</div>
        ${renderNodesTable(nodes, selectedId)}
        <div class="section-label" style="margin-top:0.55rem">Node Detail ${selectedId ? `<span style="color:#555;font-family:monospace;text-transform:none">${esc(selectedId)}</span>` : ''}</div>
        ${selectedRow ? `
          <div class="metrics-grid">
            ${metricCard('Req/min', fmtInt(selectedRow.requests), `errors ${fmtInt(selectedRow.errors)}`)}
            ${metricCard('Util', `${(selectedRow.utilization_pct || 0).toFixed(1)}%`, `peak act ${fmtInt(selectedRow.active_requests_peak || 0)}`)}
            ${metricCard('Latency p95', fmtMaybeMs(selectedRow.latency_p95_ms), `p50 ${fmtMaybeMs(selectedRow.latency_p50_ms)}`)}
            ${metricCard('Route split', `${fmtInt(selectedRow.requests_local || 0)}L / ${fmtInt(selectedRow.requests_remote || 0)}R`, '')}
          </div>
          ${miniChart('Node requests/min', nodeHist.map(r => r.requests), '#6cf')}
          ${miniChart('Node utilization %', nodeHist.map(r => r.utilization_pct), '#cc8')}
          ${miniChart('Node latency p95 ms', nodeHist.map(r => r.latency_p95_ms), '#8c8')}
        ` : `<div style="color:#666;font-size:0.58rem">No node metrics yet.</div>`}
        <div class="section-label" style="margin-top:0.55rem">Benchmarks</div>
        ${renderBenchmarkSummary(benchLatestByProbe, benches)}
      </details>`;
    }

    function renderNodesTable(rows, selectedId) {
      if (!rows.length) return '<div style="color:#666;font-size:0.58rem">No node rows in local historian yet.</div>';
      return `<table class="telemetry-table">
        <thead><tr>
          <th>Node</th><th>Req</th><th>Err</th><th>Util</th><th>P95</th><th>Route</th><th>Seen</th>
        </tr></thead>
        <tbody>
          ${rows.map(r => {
            const cls = freshnessClass(r.observed_at);
            const selected = r.source_node_id === selectedId ? ' sel' : '';
            return `<tr class="telemetry-row${selected}" onclick="selectTelemetryNode('${escAttr(r.source_node_id)}')">
              <td><span class="fresh-dot ${cls}"></span>${esc(r.source_node_id)}</td>
              <td>${fmtInt(r.requests)}</td>
              <td>${fmtInt(r.errors)}</td>
              <td>${(r.utilization_pct || 0).toFixed(1)}%</td>
              <td>${fmtMaybeMs(r.latency_p95_ms)}</td>
              <td>${fmtInt(r.requests_local || 0)}/${fmtInt(r.requests_remote || 0)}</td>
              <td>${fmtAgeSec(r.observed_at)}</td>
            </tr>`;
          }).join('')}
        </tbody>
      </table>`;
    }

    function selectTelemetryNode(nodeId) {
      T.selectedNodeId = nodeId;
      connectTelemetrySse();
      loadTelemetry(true);
      renderTelemetry();
    }

    function setTelemetryRange(v) {
      const n = Number(v);
      if (!Number.isFinite(n) || n <= 0) return;
      T.rangeMinutes = n;
      connectTelemetrySse();
      loadTelemetry(true);
      renderTelemetry();
    }

    function metricCard(k, v, sub) {
      return `<div class="metric-card"><div class="metric-k">${esc(k)}</div><div class="metric-v">${esc(v)}</div>${sub ? `<div class="metric-sub">${esc(sub)}</div>` : ''}</div>`;
    }

    function miniChart(label, valsRaw, color) {
      const vals = (valsRaw || []).map(v => (v == null ? null : Number(v))).slice(-60);
      const nums = vals.filter(v => Number.isFinite(v));
      if (!nums.length) return `<div class="telemetry-chart"><div class="label"><span>${esc(label)}</span><span>n/a</span></div><svg viewBox="0 0 220 36"><rect x="0" y="0" width="220" height="36" fill="#090909"/></svg></div>`;
      const min = Math.min(...nums);
      const max = Math.max(...nums);
      const span = Math.max(1e-6, max - min);
      const pts = vals.map((v, i) => {
        if (!Number.isFinite(v)) return null;
        const x = vals.length <= 1 ? 0 : (i / (vals.length - 1)) * 220;
        const y = 34 - ((v - min) / span) * 30;
        return `${x.toFixed(1)},${y.toFixed(1)}`;
      }).filter(Boolean).join(' ');
      return `<div class="telemetry-chart">
        <div class="label"><span>${esc(label)}</span><span>${esc(fmtMetricRange(min, max))}</span></div>
        <svg viewBox="0 0 220 36" preserveAspectRatio="none">
          <line x1="0" y1="34" x2="220" y2="34" stroke="#1a1a1a" stroke-width="1"/>
          <polyline fill="none" stroke="${color}" stroke-width="1.5" points="${pts}"/>
        </svg>
      </div>`;
    }

    function renderBenchmarkSummary(latestRows, rows) {
      if (!rows.length) return '<div style="color:#666;font-size:0.58rem">No benchmark runs yet.</div>';
      const sortedLatest = [...latestRows].sort((a,b) => a.probe_name.localeCompare(b.probe_name));
      const streamRows = rows.filter(r => r.stream);
      const nonstreamRows = rows.filter(r => !r.stream);
      return `
        <div class="metrics-grid">
          ${sortedLatest.map(r => metricCard(
            r.probe_name.replace(/^analysis_report_v1_?/, 'probe '),
            r.success ? (r.stream ? `${fmtMaybeMs(r.ttft_ms)} TTFT` : fmtMaybeMs(r.latency_ms)) : 'fail',
            r.success ? `${fmtMaybeMs(r.latency_ms)} total${r.tokens_per_sec ? ' Â· '+Number(r.tokens_per_sec).toFixed(1)+' tok/s' : ''}` : (r.error_kind || 'error')
          )).join('')}
        </div>
        ${miniChart('Benchmark non-stream latency (ms)', nonstreamRows.slice().reverse().map(r => r.latency_ms), '#6cf')}
        ${miniChart('Benchmark stream TTFT (ms)', streamRows.slice().reverse().map(r => r.ttft_ms), '#8c8')}
        <table class="telemetry-table" style="margin-top:0.35rem">
          <thead><tr><th>Probe</th><th>OK</th><th>Latency</th><th>TTFT</th><th>Tok/s</th><th>When</th></tr></thead>
          <tbody>
            ${rows.slice(0, 10).map(r => `<tr>
              <td>${esc(r.probe_name)}</td>
              <td style="color:${r.success ? '#8c8' : '#c66'}">${r.success ? 'yes' : 'no'}</td>
              <td>${fmtMaybeMs(r.latency_ms)}</td>
              <td>${fmtMaybeMs(r.ttft_ms)}</td>
              <td>${r.tokens_per_sec != null ? Number(r.tokens_per_sec).toFixed(1) : 'n/a'}</td>
              <td>${fmtAgeSec(r.observed_at)}</td>
            </tr>`).join('')}
          </tbody>
        </table>`;
    }

    function renderMeshName() {
      const el = $('meshName');
      const name = S.mesh_name;
      if (name) {
        el.innerHTML = 'Mesh: <span style="color:#aaa">' + esc(name) + '</span>';
      } else if (S.mesh_id && S.peers && S.peers.length > 0) {
        el.innerHTML = 'Mesh: <span style="color:#aaa">' + S.mesh_id.substring(0, 8) + '</span>';
      } else {
        el.textContent = '';
      }
    }

    function renderBadge() {
      const e = $('badge');
      const st = S.node_status || '';
      const model = S.model_name && S.model_name !== '(idle)' ? shortName(S.model_name) : '';
      if (st.startsWith('Serving')) {
        const color = S.llama_ready ? 'b-green' : 'b-yellow';
        if (S.llama_ready) {
          const split = st.includes('split') ? ' (split)' : '';
          e.innerHTML = `<span class="badge ${color}"><span class="dot"></span>Serving${split}</span> <span style="color:#aaa;font-size:0.7rem">${esc(model)}</span>`;
        } else {
          e.innerHTML = `<span class="badge ${color}"><span class="dot"></span>Loadingâ€¦</span> <span style="color:#666;font-size:0.7rem">${esc(model)}</span>`;
        }
      } else if (st === 'Client') {
        const hasWarm = (S.mesh_models || []).some(m => m.status === 'warm');
        e.innerHTML = `<span class="badge ${hasWarm ? 'b-green' : 'b-gray'}"><span class="dot"></span>Client</span>`;
      } else if (st === 'Worker (split)') {
        e.innerHTML = `<span class="badge b-green"><span class="dot"></span>Worker (split)</span> <span style="color:#aaa;font-size:0.7rem">${esc(model)}</span>`;
      } else if (st === 'Standby') {
        e.innerHTML = '<span class="badge b-yellow"><span class="dot"></span>Standby</span>';
      } else if (st === 'Idle') {
        e.innerHTML = '<span class="badge b-gray"><span class="dot"></span>Idle</span>';
      } else {
        e.innerHTML = '';
      }
    }

    function renderMeta() {
      const p = [];
      if (S.model_name && !S.is_client && S.model_name !== '(idle)') p.push(`Model <span>${esc(S.model_name)}</span>`);
      if (S.draft_name) p.push(`Draft <span>${esc(S.draft_name)}</span>`);
      if (S.llama_ready) p.push(`API <span>:${S.api_port}</span>`);
      $('meta').innerHTML = p.join(' Â· ');
    }

    // â”€â”€ Topology SVG â”€â”€

    function renderDiagram() {
      const el = $('diagram');
      const nodes = [];
      const isClient = S.is_client;
      if (S.node_id) nodes.push({ id: S.node_id, vram: S.my_vram_gb || 0, self: true, host: S.is_host, client: isClient, serving: S.model_name || '' });
      (S.peers || []).forEach(p => nodes.push({ id: p.id, vram: p.vram_gb, self: false, host: /^Host/.test(p.role), client: p.role === 'Client', serving: p.serving || '' }));
      if (!nodes.length) { el.innerHTML = ''; return; }

      const total = nodes.filter(n => !n.client).reduce((s, n) => s + n.vram, 0);
      const ok = S.llama_ready;
      const sel = selectedModel();
      const W = 320, nW = 140, nH = 76;

      if (nodes.length === 1) {
        el.innerHTML = mkSvg(W, nH + 16, nBox(W / 2 - nW / 2, 8, nodes[0], total, ok, sel));
        return;
      }

      const host = nodes.find(n => n.host) || nodes[0];
      const workers = nodes.filter(n => n !== host);
      const hX = W / 2 - nW / 2, hY = 10;
      const wY = nH + 48;
      const gap = Math.min(160, (W - 20) / workers.length);
      const wStart = W / 2 - (workers.length - 1) * gap / 2 - nW / 2;

      let out = '';

      workers.forEach((w, i) => {
        const wx = wStart + i * gap;
        const x1 = hX + nW / 2, y1 = hY + nH;
        const x2 = wx + nW / 2, y2 = wY;
        const my = (y1 + y2) / 2, mx = (x1 + x2) / 2;

        const col = ok ? '#2a5a2a' : '#1c1c1c';
        const dash = ok ? '' : ' stroke-dasharray="4,3"';
        out += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${col}" stroke-width="1.5"${dash}/>`;

        if (ok) {
          out += `<circle r="2" fill="#4c4" opacity="0.7"><animateMotion dur="1.8s" repeatCount="indefinite" path="M${x1},${y1} L${x2},${y2}"/></circle>`;
          out += `<circle r="2" fill="#6cf" opacity="0.5"><animateMotion dur="1.8s" repeatCount="indefinite" path="M${x2},${y2} L${x1},${y1}"/></circle>`;
        }

        const linkLabel = w.client ? 'QUIC Â· HTTP' : 'QUIC Â· RPC';
        out += `<text x="${mx}" y="${my - 3}" text-anchor="middle" fill="#333" font-size="7.5" font-family="monospace">${linkLabel}</text>`;
      });

      out += nBox(hX, hY, host, total, ok, sel);
      workers.forEach((w, i) => {
        out += nBox(wStart + i * gap, wY, w, total, ok, sel);
      });

      el.innerHTML = mkSvg(W, wY + nH + 10, out);
    }

    function nBox(x, y, n, total, ok, sel) {
      const pct = n.client ? 0 : (total > 0 ? Math.round(n.vram / total * 100) : 100);
      const servingSel = !n.client && n.serving === sel;
      const active = ok && servingSel;
      const fill = active ? '#0a1a12' : (n.self ? '#0d1a26' : '#10101c');
      const stroke = active ? '#4c4' : (ok ? (n.host ? '#2a5a2a' : n.client ? '#333' : '#1a3a5c') : '#1c1c1c');
      const sw = active ? '2' : (ok ? '1.5' : '1');
      const label = n.self ? `${n.id} (you)` : n.id;
      const role = n.client ? 'CLIENT' : (n.serving ? shortName(n.serving) : 'IDLE');
      const rc = n.client ? '#888' : (servingSel ? '#4c4' : '#6cf');
      const svc = n.client ? 'API tunnel' : (n.host ? 'llama-server' : 'rpc-server');
      const svcColor = active ? '#4c4' : '#3a3a3a';
      const vram = n.vram > 0 ? `${n.vram.toFixed(0)} GB` : '';
      const pctL = pct < 100 && total > 0 ? `${pct}%` : '';

      // Model usage bar â€” look up this node's model size from mesh_models
      const nodeModel = (S.mesh_models || []).find(m => m.name === n.serving);
      const modelGB = nodeModel ? nodeModel.size_gb : (n.self ? (S.model_size_gb || 0) : 0);
      const usagePct = (!n.client && n.vram > 0 && modelGB > 0) ? Math.min(100, Math.round(modelGB / n.vram * 100)) : 0;
      const usageLabel = (!n.client && modelGB > 0) ? `${modelGB.toFixed(1)}GB model` : '';

      const bW = 112, bH = 4, bX = x + 14, bY = y + 50;
      const b2Y = bY + bH + 2; // second bar just below first

      let extra = '';
      if (n.host && ok) {
        extra = `<rect x="${x + 97}" y="${y + 3}" width="36" height="12" rx="3" fill="#0a1a0a" stroke="#2a5a2a" stroke-width="0.5"/>
      <text x="${x + 115}" y="${y + 12}" text-anchor="middle" fill="#4c4" font-size="6.5" font-family="monospace">:${S.api_port || 9337}</text>`;
      }

      // Second bar: model usage (orange-ish for utilisation)
      const bar2 = usagePct > 0 ? `
    <rect x="${bX}" y="${b2Y}" width="${bW}" height="${bH}" rx="1.5" fill="#151515"/>
    <rect x="${bX}" y="${b2Y}" width="${bW * usagePct / 100}" height="${bH}" rx="1.5" fill="${usagePct > 80 ? '#8a4a2a' : '#5a4a2a'}"/>` : '';

      return `<g>
    <rect x="${x}" y="${y}" width="140" height="76" rx="6" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/>
    <text x="${x + 70}" y="${y + 15}" text-anchor="middle" fill="${rc}" font-size="8" font-family="monospace" font-weight="600">${role}</text>
    <text x="${x + 70}" y="${y + 27}" text-anchor="middle" fill="#6cf" font-size="9" font-family="monospace">${esc(label)}</text>
    <text x="${x + 70}" y="${y + 38}" text-anchor="middle" fill="${svcColor}" font-size="6.5" font-family="monospace">${svc}</text>
    <rect x="${bX}" y="${bY}" width="${bW}" height="${bH}" rx="1.5" fill="#151515"/>
    <rect x="${bX}" y="${bY}" width="${bW * pct / 100}" height="${bH}" rx="1.5" fill="${servingSel ? '#2a5a2a' : '#1a3a5c'}"/>
    ${bar2}
    <text x="${bX}" y="${b2Y + bH + 9}" fill="#444" font-size="6.5" font-family="monospace">${vram}${usageLabel ? ' Â· ' + usageLabel : ''}</text>
    <text x="${bX + bW}" y="${b2Y + bH + 9}" text-anchor="end" fill="#444" font-size="6.5" font-family="monospace">${usagePct > 0 ? usagePct + '% used' : pctL}</text>
    ${extra}
  </g>`;
    }

    function mkSvg(w, h, c) { return `<svg viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg">${c}</svg>`; }

    // â”€â”€ Status line â”€â”€

    function renderStatus() {
      const el = $('status');
      const peers = (S.peers || []).length;
      const model = S.model_name || '';
      const n = peers + 1;
      const gpuVram = (S.is_client ? 0 : (S.my_vram_gb || 0)) + (S.peers || []).filter(p => p.role !== 'Client').reduce((s, p) => s + p.vram_gb, 0);
      const vramStr = gpuVram > 0 ? ` Â· ${gpuVram.toFixed(0)} GB mesh` : '';
      const hasWarm = (S.mesh_models || []).some(m => m.status === 'warm');
      if (S.llama_ready || (S.is_client && hasWarm)) {
        el.innerHTML = `<div class="status-line ok">âœ“ Connected Â· ${n} node${n > 1 ? 's' : ''}${vramStr}</div>`;
      } else if (S.is_host) {
        el.innerHTML = `<div class="status-line">Loading ${esc(model)}â€¦${n > 1 ? ' Â· ' + n + ' nodes' + vramStr : ''}</div>`;
      } else if (S.is_client && peers > 0) {
        el.innerHTML = `<div class="status-line">Connecting Â· ${n} nodes${vramStr}</div>`;
      } else if (peers > 0) {
        el.innerHTML = `<div class="status-line">Waiting for host Â· ${n} nodes${vramStr}</div>`;
      } else if (S.node_id) {
        el.innerHTML = `<div class="status-line">Waiting for peersâ€¦</div>`;
      } else {
        el.innerHTML = '';
      }
    }

    // â”€â”€ Models list â”€â”€

    function renderModels() {
      const el = $('models');
      const models = S.mesh_models || [];
      if (models.length <= 1) { el.innerHTML = ''; return; }
      el.innerHTML = '<div class="section-label">Models</div><div class="models-list">' +
        models.map(m => {
          const warm = m.status === 'warm';
          const nodes = m.node_count > 0 ? `${m.node_count} node${m.node_count > 1 ? 's' : ''}` : 'not loaded';
          return `<div class="model-item">
        <span class="model-dot ${warm ? 'warm' : 'cold'}"></span>
        <span class="model-name ${warm ? 'warm' : ''}">${esc(shortName(m.name))}</span>
        <span class="model-info">${nodes}</span>
      </div>`;
        }).join('') + '</div>';
    }

    // â”€â”€ Agent commands (visible inline: API endpoint only) â”€â”€

    function renderAgents() {
      const el = $('agents');
      if (!S.llama_ready) { el.innerHTML = ''; return; }
      const p = S.api_port || 9337;
      el.innerHTML = `<div class="agent-row"><span class="agent-name">API</span><div class="cmd-sm" style="user-select:all">http://localhost:${p}/v1</div></div>`;
    }

    // â”€â”€ Join hint (tiny, expands) â”€â”€

    // â”€â”€ Invite others â”€â”€

    // â”€â”€ Getting started (idle mode only) â”€â”€

    let gettingStartedRendered = false;
    function renderGettingStarted() {
      const el = $('gettingStarted');
      if (S.node_status !== 'Idle') { el.innerHTML = ''; gettingStartedRendered = false; return; }
      if (gettingStartedRendered) return;
      gettingStartedRendered = true;
      el.innerHTML = `
        <details class="panel-section">
          <summary>Start a mesh</summary>
          <div class="panel-desc">Serve a model from this machine. Others can join with your invite token.</div>
          <pre style="background:#0a0a0a;border:1px solid #1a1a1a;border-radius:4px;padding:0.4rem 0.6rem;font-size:0.55rem;color:#8c8;margin:0.3rem 0;overflow-x:auto;white-space:pre-wrap">mesh-llm --model Qwen2.5-32B</pre>
          <div class="panel-desc" style="margin-top:0.3rem">Or create a named mesh everyone can join with the same command:</div>
          <pre style="background:#0a0a0a;border:1px solid #1a1a1a;border-radius:4px;padding:0.4rem 0.6rem;font-size:0.55rem;color:#8c8;margin:0.3rem 0;overflow-x:auto;white-space:pre-wrap">mesh-llm --auto --model GLM-4.7-Flash-Q4_K_M --mesh-name "my-mesh"</pre>
        </details>
        <details class="panel-section">
          <summary>Join a mesh</summary>
          <div class="panel-desc">Discover public meshes and join automatically, or paste an invite token.</div>
          <pre style="background:#0a0a0a;border:1px solid #1a1a1a;border-radius:4px;padding:0.4rem 0.6rem;font-size:0.55rem;color:#8c8;margin:0.3rem 0;overflow-x:auto;white-space:pre-wrap">mesh-llm --auto</pre>
          <pre style="background:#0a0a0a;border:1px solid #1a1a1a;border-radius:4px;padding:0.4rem 0.6rem;font-size:0.55rem;color:#8c8;margin:0.3rem 0;overflow-x:auto;white-space:pre-wrap">mesh-llm --join &lt;token&gt;</pre>
          <div class="panel-desc" style="margin-top:0.3rem">Join as API-only client (no GPU):</div>
          <pre style="background:#0a0a0a;border:1px solid #1a1a1a;border-radius:4px;padding:0.4rem 0.6rem;font-size:0.55rem;color:#8c8;margin:0.3rem 0;overflow-x:auto;white-space:pre-wrap">mesh-llm --client --auto</pre>
        </details>`;
    }

    // â”€â”€ Invite others â”€â”€

    let inviteRendered = false;
    function renderInvite() {
      const el = $('inviteSection');
      if (S.is_client) { el.innerHTML = ''; return; }
      const token = S.token || '';
      const hasToken = token && S.model_name && S.model_name !== '(idle)';
      if (!hasToken) { el.innerHTML = ''; return; }
      if (inviteRendered) {
        const tok = document.getElementById('inviteToken');
        if (tok) tok.textContent = token;
        return;
      }
      inviteRendered = true;
      el.innerHTML = `<details class="panel-section">
        <summary>Invite others to your mesh</summary>
        <div class="panel-desc">Share this token with others so they can join your mesh. They run <strong style="color:#aaa">mesh-llm --join &lt;token&gt;</strong> or paste it into their console.</div>
        <div style="display:flex;align-items:center;gap:0.4rem">
          <div class="panel-tok" id="inviteToken" style="flex:1">${esc(token)}</div>
          <button class="copy-btn" onclick="copyToken(this)" title="Copy invite token">ðŸ“‹ Copy</button>
        </div>
      </details>`;
    }

    function copyToken(btn) {
      const tok = document.getElementById('inviteToken');
      if (!tok) return;
      navigator.clipboard.writeText(tok.textContent).then(() => {
        const prev = btn.textContent;
        btn.textContent = 'âœ“ Copied';
        setTimeout(() => btn.textContent = prev, 2000);
      }).catch(() => {
        const range = document.createRange();
        range.selectNodeContents(tok);
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);
      });
    }

    // â”€â”€ Join a mesh â”€â”€


    // â”€â”€ Discover public meshes â”€â”€

    let discoverLoaded = false;
    function renderDiscover() {
      const el = $('discoverSection');
      if (S.is_client) { el.innerHTML = ''; return; }
      if (el.innerHTML && el.querySelector('details[open]')) return;
      el.innerHTML = `<details class="panel-section" ontoggle="if(this.open && !discoverLoaded) { discoverLoaded = true; loadDiscover(); }">
        <summary>Public meshes</summary>
        <div class="panel-desc">Meshes published to the directory. Run the command to join one.</div>
        <div id="discoverContent"></div>
      </details>`;
    }

    async function loadDiscover() {
      const el = $('discoverContent');
      if (!el) return;
      el.innerHTML = '<div style="color:#777;font-size:0.6rem;padding:0.3rem 0">Searchingâ€¦</div>';
      try {
        const r = await fetch('/api/discover');
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const meshes = await r.json();
        if (!meshes.length) { el.innerHTML = '<div style="color:#777;font-size:0.6rem">No public meshes found.</div>'; return; }
        const myMeshId = S.mesh_id || '';
        el.innerHTML = meshes.map(m => {
          const l = m.listing;
          const isCurrent = myMeshId && l.mesh_id && l.mesh_id === myMeshId;
          const served = (l.serving || []).map(shortName).join(', ');
          const nodes = l.node_count || 0;
          const vram = l.total_vram_bytes > 0 ? `${(l.total_vram_bytes / 1e9).toFixed(0)}GB` : '';
          const stats = [nodes + ' node' + (nodes !== 1 ? 's' : ''), vram].filter(Boolean).join(' Â· ');
          const joinCmd = `mesh-llm --join ${l.invite_token.substring(0, 20)}â€¦`;
          return `<div class="discover-item" style="${isCurrent ? 'border-color:#2a5a2a' : ''}">
            <div class="discover-item-hdr">
              <span class="discover-name">${esc(l.name || m.publisher_npub.substring(0, 12))}</span>
              ${isCurrent ? '<span style="color:#4c4;font-size:0.5rem;font-weight:600">âœ“ connected</span>' : ''}
              ${l.region ? `<span class="discover-region">${esc(l.region)}</span>` : ''}
            </div>
            <div class="discover-stats">${stats}</div>
            ${served ? `<div class="discover-models" title="${esc((l.serving||[]).join(', '))}">${esc(served)}</div>` : ''}
            ${isCurrent ? '' : `<pre onclick="navigator.clipboard.writeText('mesh-llm --join ${esc(l.invite_token)}')" title="Click to copy" style="cursor:pointer;background:#0a0a0a;border:1px solid #1a1a1a;border-radius:4px;padding:0.3rem 0.5rem;font-size:0.5rem;color:#8c8;margin:0.2rem 0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${esc(joinCmd)} <span style="color:#555">ðŸ“‹</span></pre>`}
          </div>`;
        }).join('');
      } catch (e) {
        discoverLoaded = false;
        el.innerHTML = `<div style="color:#c66;font-size:0.6rem">Could not reach directory. Check your network connection and try again.</div>`;
      }
    }

    // â”€â”€ Using your mesh â”€â”€

    function renderApiSection() {
      const el = $('apiSection');
      if (el.innerHTML && el.querySelector('details[open]')) return;
      if (!S.llama_ready) { el.innerHTML = ''; return; }
      const p = S.api_port || 9337;
      el.innerHTML = `<details class="panel-section"><summary>Using your mesh</summary>
        <div class="panel-desc">
          Your mesh exposes an OpenAI-compatible API. Use it with any tool that supports the OpenAI format â€” pi, goose, Continue, aider, Open WebUI, curl, or anything else.
        </div>
        <div class="panel-row">
          <div class="panel-label">API endpoint</div>
          <div style="display:flex;align-items:center;gap:0.4rem">
            <div class="panel-val" style="flex:1" id="apiUrl">http://localhost:${p}/v1</div>
            <button class="copy-btn" onclick="copyEl('apiUrl', this)">ðŸ“‹ Copy</button>
          </div>
        </div>
        <div style="font-size:0.55rem;color:#777;line-height:1.5;margin-top:0.1rem">
          API key: <code style="color:#aaa;background:#111;padding:0.1rem 0.3rem;border-radius:2px">mesh</code> Â· 
          Model list: <code style="color:#aaa;background:#111;padding:0.1rem 0.3rem;border-radius:2px">/v1/models</code>
        </div>
      </details>`;
    }

    function copyEl(id, btn) {
      const el = document.getElementById(id);
      if (!el) return;
      navigator.clipboard.writeText(el.textContent).then(() => {
        const prev = btn.textContent;
        btn.textContent = 'âœ“ Copied';
        setTimeout(() => btn.textContent = prev, 2000);
      });
    }

    function shortName(n) { return (n || '').replace(/-Q\w+$/, '').replace(/-Instruct/, ''); }
    function fmtInt(n) { return Number(n || 0).toLocaleString(); }
    function fmtMaybeMs(v) { return (v == null || !Number.isFinite(Number(v))) ? 'n/a' : `${Number(v).toFixed(0)}ms`; }
    function fmtMetricRange(min, max) {
      if (!Number.isFinite(min) || !Number.isFinite(max)) return 'n/a';
      if (Math.abs(max - min) < 0.001) return `${max.toFixed(1)}`;
      return `${min.toFixed(1)}-${max.toFixed(1)}`;
    }
    function latestDefined(arr) {
      for (let i = arr.length - 1; i >= 0; i--) if (arr[i] != null) return arr[i];
      return null;
    }
    function latestBy(rows, keyFn) {
      const m = new Map();
      for (const r of rows || []) {
        const k = keyFn(r);
        const prev = m.get(k);
        if (!prev || Number(r.ts || 0) > Number(prev.ts || 0)) m.set(k, r);
      }
      return Array.from(m.values());
    }
    function fmtBytes(n) {
      n = Number(n || 0);
      const units = ['B', 'KB', 'MB', 'GB', 'TB'];
      let i = 0;
      while (n >= 1024 && i < units.length - 1) { n /= 1024; i++; }
      return `${n.toFixed(i ? 1 : 0)} ${units[i]}`;
    }
    function fmtAgeSec(ts) {
      if (!ts) return 'n/a';
      const d = Math.max(0, Math.floor(Date.now() / 1000 - Number(ts)));
      if (d < 60) return `${d}s`;
      const m = Math.floor(d / 60);
      return `${m}m`;
    }
    function freshnessClass(observedAt) {
      const age = Math.max(0, Math.floor(Date.now() / 1000 - Number(observedAt || 0)));
      if (age <= 90) return 'ok';
      if (age <= 180) return 'warn';
      return 'stale';
    }
    function escAttr(s) { return String(s).replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }

    // â”€â”€ Model picker â”€â”€

    function updateModelPicker() {
      const sel = $('modelPicker');
      const warm = (S.mesh_models || []).filter(m => m.status === 'warm').map(m => m.name);
      // Fall back to just our model if no mesh_models
      if (!warm.length && S.model_name) warm.push(S.model_name);
      const prev = sel.value;
      // Only rebuild if options changed
      const current = Array.from(sel.options).map(o => o.value).join(',');
      const next = warm.join(',');
      if (current !== next) {
        sel.innerHTML = warm.map(m => `<option value="${esc(m)}">${esc(shortName(m))}</option>`).join('');
        if (warm.includes(prev)) sel.value = prev;
      }
      sel.style.display = warm.length > 1 ? '' : 'none';
    }

    function selectedModel() {
      const sel = $('modelPicker');
      return sel.value || S.model_name || 'test';
    }

    // â”€â”€ Chat â”€â”€

    let chatHistory = [];

    async function send() {
      const clientOk = S.is_client && (S.mesh_models || []).some(m => m.status === 'warm');
      if (!S.llama_ready && !clientOk) return;
      const inp = $('inp');
      const msg = inp.value.trim(); if (!msg) return;
      inp.value = '';
      const el = $('msgs');
      const model = selectedModel();
      const label = shortName(model);
      el.innerHTML += `<div class="mu">â€º ${esc(msg)}${(S.mesh_models || []).filter(m => m.status === 'warm').length > 1 ? ` <span style="color:#444;font-size:0.7rem">${esc(label)}</span>` : ''}</div>`;
      chatHistory.push({ role: 'user', content: msg });
      const bot = document.createElement('div'); bot.className = 'mb';
      const meta = document.createElement('div'); meta.className = 'mmeta';
      el.appendChild(bot); el.scrollTop = el.scrollHeight;
      el.appendChild(meta); el.scrollTop = el.scrollHeight;
      const reqStart = performance.now();
      try {
        const r = await fetch('/api/chat', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ model: model, messages: chatHistory, stream: true, stream_options: { include_usage: true } }),
        });
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const reader = r.body.getReader();
        const dec = new TextDecoder(); let buf = ''; let full = '';
        let completionTokens = null;
        let firstTokenAt = null;
        while (true) {
          const { done, value } = await reader.read(); if (done) break;
          buf += dec.decode(value, { stream: true });
          const lines = buf.split('\n'); buf = lines.pop() || '';
          for (const l of lines) {
            if (!l.startsWith('data: ')) continue;
            const d = l.slice(6).trim(); if (d === '[DONE]') continue;
            try {
              const c = JSON.parse(d);
              if (c.usage && Number.isFinite(c.usage.completion_tokens)) completionTokens = c.usage.completion_tokens;
              const t = c.choices?.[0]?.delta?.content || c.choices?.[0]?.delta?.reasoning_content || '';
              if (t) {
                if (firstTokenAt == null) firstTokenAt = performance.now();
                full += t; bot.textContent += t; el.scrollTop = el.scrollHeight;
              }
            } catch { }
          }
        }
        if (!full) { bot.textContent = '(empty response)'; }
        const endAt = performance.now();
        const genStart = firstTokenAt ?? reqStart;
        const genSecs = Math.max(0.001, (endAt - genStart) / 1000);
        const ttftMs = Math.max(0, Math.round((firstTokenAt ?? endAt) - reqStart));
        const tokenCount = Number.isFinite(completionTokens)
          ? completionTokens
          : Math.max(1, Math.round((full || '').length / 4)); // rough fallback
        const tps = tokenCount / genSecs;
        meta.textContent = `${tokenCount} tok Â· ${tps.toFixed(1)} tok/s avg Â· TTFT ${ttftMs}ms`;
        chatHistory.push({ role: 'assistant', content: full || '' });
      } catch (e) { bot.remove(); meta.remove(); el.innerHTML += `<div class="me">Error: ${esc(e.message)}</div>`; chatHistory.pop(); }
      el.scrollTop = el.scrollHeight;
    }

    function esc(s) { return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }
    fetch('/api/status').then(r => r.json()).then(d => { S = d; render(); });
    loadTelemetry();
    connectTelemetrySse();
  </script>
</body>

</html>
